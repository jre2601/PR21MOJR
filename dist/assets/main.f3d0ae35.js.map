{"version":3,"file":"main.f3d0ae35.js","sources":["../../node_modules/ol/webgl.js","../../node_modules/ol/webgl/Buffer.js","../../node_modules/ol/webgl/ContextEventType.js","../../node_modules/ol/webgl/PostProcessingPass.js","../../node_modules/ol/vec/mat4.js","../../node_modules/ol/webgl/Helper.js","../../node_modules/ol/renderer/webgl/Layer.js","../../node_modules/ol/webgl/RenderTarget.js","../../node_modules/ol/worker/webgl.js","../../node_modules/ol/renderer/webgl/PointsLayer.js","../../node_modules/ol/layer/Heatmap.js","../../visualization.js"],"sourcesContent":["/**\n * @module ol/webgl\n */\nimport { SAFARI_BUG_237906 } from './has.js';\nimport { assign } from './obj.js';\n/**\n * Constants taken from goog.webgl\n */\n/**\n * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing vertices data, such as\n * position, color, texture coordinate, etc. These vertices are then referenced by an index buffer\n * to be drawn on screen (see {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER}).\n * @const\n * @type {number}\n * @api\n */\nexport var ARRAY_BUFFER = 0x8892;\n/**\n * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing indices data.\n * Index buffers are essentially lists of references to vertices defined in a vertex buffer\n * (see {@link module:ol/webgl.ARRAY_BUFFER}), and define the primitives (triangles) to be drawn.\n * @const\n * @type {number}\n * @api\n */\nexport var ELEMENT_ARRAY_BUFFER = 0x8893;\n/**\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\n * @const\n * @type {number}\n * @api\n */\nexport var STREAM_DRAW = 0x88e0;\n/**\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\n * @const\n * @type {number}\n * @api\n */\nexport var STATIC_DRAW = 0x88e4;\n/**\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\n * @const\n * @type {number}\n * @api\n */\nexport var DYNAMIC_DRAW = 0x88e8;\n/**\n * @const\n * @type {number}\n */\nexport var UNSIGNED_BYTE = 0x1401;\n/**\n * @const\n * @type {number}\n */\nexport var UNSIGNED_SHORT = 0x1403;\n/**\n * @const\n * @type {number}\n */\nexport var UNSIGNED_INT = 0x1405;\n/**\n * @const\n * @type {number}\n */\nexport var FLOAT = 0x1406;\n/** end of goog.webgl constants\n */\n/**\n * @const\n * @type {Array<string>}\n */\nvar CONTEXT_IDS = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];\n/**\n * @param {HTMLCanvasElement} canvas Canvas.\n * @param {Object} [opt_attributes] Attributes.\n * @return {WebGLRenderingContext} WebGL rendering context.\n */\nexport function getContext(canvas, opt_attributes) {\n    var attributes = assign({\n        preserveDrawingBuffer: true,\n        antialias: SAFARI_BUG_237906 ? false : true, // https://bugs.webkit.org/show_bug.cgi?id=237906\n    }, opt_attributes);\n    var ii = CONTEXT_IDS.length;\n    for (var i = 0; i < ii; ++i) {\n        try {\n            var context = canvas.getContext(CONTEXT_IDS[i], attributes);\n            if (context) {\n                return /** @type {!WebGLRenderingContext} */ (context);\n            }\n        }\n        catch (e) {\n            // pass\n        }\n    }\n    return null;\n}\n/**\n * @type {Array<string>}\n */\nvar supportedExtensions;\n/**\n * @return {Array<string>} List of supported WebGL extensions.\n */\nexport function getSupportedExtensions() {\n    if (!supportedExtensions) {\n        var canvas = document.createElement('canvas');\n        var gl = getContext(canvas);\n        if (gl) {\n            supportedExtensions = gl.getSupportedExtensions();\n        }\n    }\n    return supportedExtensions;\n}\n//# sourceMappingURL=webgl.js.map","/**\n * @module ol/webgl/Buffer\n */\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER, STATIC_DRAW, STREAM_DRAW, } from '../webgl.js';\nimport { assert } from '../asserts.js';\n/**\n * Used to describe the intended usage for the data: `STATIC_DRAW`, `STREAM_DRAW`\n * or `DYNAMIC_DRAW`.\n * @enum {number}\n */\nexport var BufferUsage = {\n    STATIC_DRAW: STATIC_DRAW,\n    STREAM_DRAW: STREAM_DRAW,\n    DYNAMIC_DRAW: DYNAMIC_DRAW,\n};\n/**\n * @classdesc\n * Object used to store an array of data as well as usage information for that data.\n * Stores typed arrays internally, either Float32Array or Uint16/32Array depending on\n * the buffer type (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER) and available extensions.\n *\n * To populate the array, you can either use:\n * * A size using `#ofSize(buffer)`\n * * An `ArrayBuffer` object using `#fromArrayBuffer(buffer)`\n * * A plain array using `#fromArray(array)`\n *\n * Note:\n * See the documentation of [WebGLRenderingContext.bufferData](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData)\n * for more info on buffer usage.\n * @api\n */\nvar WebGLArrayBuffer = /** @class */ (function () {\n    /**\n     * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.\n     * @param {number} [opt_usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.\n     * Default is `DYNAMIC_DRAW`.\n     */\n    function WebGLArrayBuffer(type, opt_usage) {\n        /**\n         * @private\n         * @type {Float32Array|Uint32Array}\n         */\n        this.array = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.type = type;\n        assert(type === ARRAY_BUFFER || type === ELEMENT_ARRAY_BUFFER, 62);\n        /**\n         * @private\n         * @type {number}\n         */\n        this.usage = opt_usage !== undefined ? opt_usage : BufferUsage.STATIC_DRAW;\n    }\n    /**\n     * Populates the buffer with an array of the given size (all values will be zeroes).\n     * @param {number} size Array size\n     */\n    WebGLArrayBuffer.prototype.ofSize = function (size) {\n        this.array = new (getArrayClassForType(this.type))(size);\n    };\n    /**\n     * Populates the buffer with an array of the given size (all values will be zeroes).\n     * @param {Array<number>} array Numerical array\n     */\n    WebGLArrayBuffer.prototype.fromArray = function (array) {\n        var arrayClass = getArrayClassForType(this.type);\n        this.array = arrayClass.from\n            ? arrayClass.from(array)\n            : new arrayClass(array);\n    };\n    /**\n     * Populates the buffer with a raw binary array buffer.\n     * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been\n     * initialized for the same typed array class.\n     */\n    WebGLArrayBuffer.prototype.fromArrayBuffer = function (buffer) {\n        this.array = new (getArrayClassForType(this.type))(buffer);\n    };\n    /**\n     * @return {number} Buffer type.\n     */\n    WebGLArrayBuffer.prototype.getType = function () {\n        return this.type;\n    };\n    /**\n     * Will return null if the buffer was not initialized\n     * @return {Float32Array|Uint32Array} Array.\n     */\n    WebGLArrayBuffer.prototype.getArray = function () {\n        return this.array;\n    };\n    /**\n     * @return {number} Usage.\n     */\n    WebGLArrayBuffer.prototype.getUsage = function () {\n        return this.usage;\n    };\n    /**\n     * Will return 0 if the buffer is not initialized\n     * @return {number} Array size\n     */\n    WebGLArrayBuffer.prototype.getSize = function () {\n        return this.array ? this.array.length : 0;\n    };\n    return WebGLArrayBuffer;\n}());\n/**\n * Returns a typed array constructor based on the given buffer type\n * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.\n * @return {Float32ArrayConstructor|Uint32ArrayConstructor} The typed array class to use for this buffer.\n */\nexport function getArrayClassForType(type) {\n    switch (type) {\n        case ARRAY_BUFFER:\n            return Float32Array;\n        case ELEMENT_ARRAY_BUFFER:\n            return Uint32Array;\n        default:\n            return Float32Array;\n    }\n}\nexport default WebGLArrayBuffer;\n//# sourceMappingURL=Buffer.js.map","/**\n * @module ol/webgl/ContextEventType\n */\n/**\n * @enum {string}\n */\nexport default {\n    LOST: 'webglcontextlost',\n    RESTORED: 'webglcontextrestored',\n};\n//# sourceMappingURL=ContextEventType.js.map","/**\n * @module ol/webgl/PostProcessingPass\n */\nimport { getUid } from '../util.js';\nvar DEFAULT_VERTEX_SHADER = \"\\n  precision mediump float;\\n  \\n  attribute vec2 a_position;\\n  varying vec2 v_texCoord;\\n  varying vec2 v_screenCoord;\\n  \\n  uniform vec2 u_screenSize;\\n   \\n  void main() {\\n    v_texCoord = a_position * 0.5 + 0.5;\\n    v_screenCoord = v_texCoord * u_screenSize;\\n    gl_Position = vec4(a_position, 0.0, 1.0);\\n  }\\n\";\nvar DEFAULT_FRAGMENT_SHADER = \"\\n  precision mediump float;\\n   \\n  uniform sampler2D u_image;\\n  uniform float u_opacity;\\n   \\n  varying vec2 v_texCoord;\\n   \\n  void main() {\\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\\n  }\\n\";\n/**\n * @typedef {Object} Options\n * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"./Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {import(\"./Helper\").UniformValue} value Value\n * @property {number} location Location\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n/**\n * @classdesc\n * This class is used to define Post Processing passes with custom shaders and uniforms.\n * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.\n *\n * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that\n * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).\n * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.\n *\n * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be\n * premultiplied.\n *\n * Default shaders are shown hereafter:\n *\n * * Vertex shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   attribute vec2 a_position;\n *   varying vec2 v_texCoord;\n *   varying vec2 v_screenCoord;\n *\n *   uniform vec2 u_screenSize;\n *\n *   void main() {\n *     v_texCoord = a_position * 0.5 + 0.5;\n *     v_screenCoord = v_texCoord * u_screenSize;\n *     gl_Position = vec4(a_position, 0.0, 1.0);\n *   }\n *   ```\n *\n * * Fragment shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   uniform sampler2D u_image;\n *   uniform float u_opacity;\n *\n *   varying vec2 v_texCoord;\n *\n *   void main() {\n *     gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n *   }\n *   ```\n *\n * @api\n */\nvar WebGLPostProcessingPass = /** @class */ (function () {\n    /**\n     * @param {Options} options Options.\n     */\n    function WebGLPostProcessingPass(options) {\n        this.gl_ = options.webGlContext;\n        var gl = this.gl_;\n        this.scaleRatio_ = options.scaleRatio || 1;\n        this.renderTargetTexture_ = gl.createTexture();\n        this.renderTargetTextureSize_ = null;\n        this.frameBuffer_ = gl.createFramebuffer();\n        // compile the program for the frame buffer\n        // TODO: make compilation errors show up\n        var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);\n        gl.compileShader(vertexShader);\n        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);\n        gl.compileShader(fragmentShader);\n        this.renderTargetProgram_ = gl.createProgram();\n        gl.attachShader(this.renderTargetProgram_, vertexShader);\n        gl.attachShader(this.renderTargetProgram_, fragmentShader);\n        gl.linkProgram(this.renderTargetProgram_);\n        // bind the vertices buffer for the frame buffer\n        this.renderTargetVerticesBuffer_ = gl.createBuffer();\n        var verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);\n        this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, 'a_position');\n        this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_screenSize');\n        this.renderTargetOpacityLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_opacity');\n        this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_image');\n        /**\n         * Holds info about custom uniforms used in the post processing pass\n         * @type {Array<UniformInternalDescription>}\n         * @private\n         */\n        this.uniforms_ = [];\n        options.uniforms &&\n            Object.keys(options.uniforms).forEach(function (name) {\n                this.uniforms_.push({\n                    value: options.uniforms[name],\n                    location: gl.getUniformLocation(this.renderTargetProgram_, name),\n                });\n            }.bind(this));\n    }\n    /**\n     * Get the WebGL rendering context\n     * @return {WebGLRenderingContext} The rendering context.\n     * @api\n     */\n    WebGLPostProcessingPass.prototype.getGL = function () {\n        return this.gl_;\n    };\n    /**\n     * Initialize the render target texture of the post process, make sure it is at the\n     * right size and bind it as a render target for the next draw calls.\n     * The last step to be initialized will be the one where the primitives are rendered.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n     * @api\n     */\n    WebGLPostProcessingPass.prototype.init = function (frameState) {\n        var gl = this.getGL();\n        var textureSize = [\n            gl.drawingBufferWidth * this.scaleRatio_,\n            gl.drawingBufferHeight * this.scaleRatio_,\n        ];\n        // rendering goes to my buffer\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());\n        gl.viewport(0, 0, textureSize[0], textureSize[1]);\n        // if size has changed: adjust canvas & render target texture\n        if (!this.renderTargetTextureSize_ ||\n            this.renderTargetTextureSize_[0] !== textureSize[0] ||\n            this.renderTargetTextureSize_[1] !== textureSize[1]) {\n            this.renderTargetTextureSize_ = textureSize;\n            // create a new texture\n            var level = 0;\n            var internalFormat = gl.RGBA;\n            var border = 0;\n            var format = gl.RGBA;\n            var type = gl.UNSIGNED_BYTE;\n            var data = null;\n            gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format, type, data);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            // bind the texture to the framebuffer\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);\n        }\n    };\n    /**\n     * Render to the next postprocessing pass (or to the canvas if final pass).\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n     * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional\n     * @param {function(WebGLRenderingContext, import(\"../PluggableMap.js\").FrameState):void} [preCompose] Called before composing.\n     * @param {function(WebGLRenderingContext, import(\"../PluggableMap.js\").FrameState):void} [postCompose] Called before composing.\n     * @api\n     */\n    WebGLPostProcessingPass.prototype.apply = function (frameState, nextPass, preCompose, postCompose) {\n        var gl = this.getGL();\n        var size = frameState.size;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n        if (!nextPass) {\n            // clear the canvas if we are the first to render to it\n            // and preserveDrawingBuffer is true\n            var canvasId = getUid(gl.canvas);\n            if (!frameState.renderTargets[canvasId]) {\n                var attributes = gl.getContextAttributes();\n                if (attributes && attributes.preserveDrawingBuffer) {\n                    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n                    gl.clear(gl.COLOR_BUFFER_BIT);\n                }\n                frameState.renderTargets[canvasId] = true;\n            }\n        }\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n        gl.useProgram(this.renderTargetProgram_);\n        gl.enableVertexAttribArray(this.renderTargetAttribLocation_);\n        gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);\n        gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);\n        gl.uniform1i(this.renderTargetTextureLocation_, 0);\n        var opacity = frameState.layerStatesArray[frameState.layerIndex].opacity;\n        gl.uniform1f(this.renderTargetOpacityLocation_, opacity);\n        this.applyUniforms(frameState);\n        if (preCompose) {\n            preCompose(gl, frameState);\n        }\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        if (postCompose) {\n            postCompose(gl, frameState);\n        }\n    };\n    /**\n     * @return {WebGLFramebuffer} Frame buffer\n     * @api\n     */\n    WebGLPostProcessingPass.prototype.getFrameBuffer = function () {\n        return this.frameBuffer_;\n    };\n    /**\n     * Sets the custom uniforms based on what was given in the constructor.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLPostProcessingPass.prototype.applyUniforms = function (frameState) {\n        var gl = this.getGL();\n        var value;\n        var textureSlot = 1;\n        this.uniforms_.forEach(function (uniform) {\n            value =\n                typeof uniform.value === 'function'\n                    ? uniform.value(frameState)\n                    : uniform.value;\n            // apply value based on type\n            if (value instanceof HTMLCanvasElement || value instanceof ImageData) {\n                // create a texture & put data\n                if (!uniform.texture) {\n                    uniform.texture = gl.createTexture();\n                }\n                gl.activeTexture(gl[\"TEXTURE\".concat(textureSlot)]);\n                gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                if (value instanceof ImageData) {\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));\n                }\n                else {\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);\n                }\n                // fill texture slots\n                gl.uniform1i(uniform.location, textureSlot++);\n            }\n            else if (Array.isArray(value)) {\n                switch (value.length) {\n                    case 2:\n                        gl.uniform2f(uniform.location, value[0], value[1]);\n                        return;\n                    case 3:\n                        gl.uniform3f(uniform.location, value[0], value[1], value[2]);\n                        return;\n                    case 4:\n                        gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);\n                        return;\n                    default:\n                        return;\n                }\n            }\n            else if (typeof value === 'number') {\n                gl.uniform1f(uniform.location, value);\n            }\n        });\n    };\n    return WebGLPostProcessingPass;\n}());\nexport default WebGLPostProcessingPass;\n//# sourceMappingURL=PostProcessingPass.js.map","/**\n * @module ol/vec/mat4\n */\n/**\n * @return {Array<number>} \"4x4 matrix representing a 3D identity transform.\"\n */\nexport function create() {\n    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n/**\n * @param {Array<number>} mat4 Flattened 4x4 matrix receiving the result.\n * @param {import(\"../transform.js\").Transform} transform Transformation matrix.\n * @return {Array<number>} \"2D transformation matrix as flattened 4x4 matrix.\"\n */\nexport function fromTransform(mat4, transform) {\n    mat4[0] = transform[0];\n    mat4[1] = transform[1];\n    mat4[4] = transform[2];\n    mat4[5] = transform[3];\n    mat4[12] = transform[4];\n    mat4[13] = transform[5];\n    return mat4;\n}\n//# sourceMappingURL=mat4.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/webgl/Helper\n */\nimport ContextEventType from '../webgl/ContextEventType.js';\nimport Disposable from '../Disposable.js';\nimport WebGLPostProcessingPass from './PostProcessingPass.js';\nimport { FLOAT, UNSIGNED_BYTE, UNSIGNED_INT, UNSIGNED_SHORT, getContext, } from '../webgl.js';\nimport { clear } from '../obj.js';\nimport { compose as composeTransform, create as createTransform, reset as resetTransform, rotate as rotateTransform, scale as scaleTransform, } from '../transform.js';\nimport { create, fromTransform } from '../vec/mat4.js';\nimport { getUid } from '../util.js';\n/**\n * @typedef {Object} BufferCacheEntry\n * @property {import(\"./Buffer.js\").default} buffer Buffer.\n * @property {WebGLBuffer} webGlBuffer WebGlBuffer.\n */\n/**\n * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.\n * @enum {number}\n */\nexport var ShaderType = {\n    FRAGMENT_SHADER: 0x8b30,\n    VERTEX_SHADER: 0x8b31,\n};\n/**\n * Uniform names used in the default shaders: `PROJECTION_MATRIX`, `OFFSET_SCALE_MATRIX`.\n * and `OFFSET_ROTATION_MATRIX`.\n * @enum {string}\n */\nexport var DefaultUniform = {\n    PROJECTION_MATRIX: 'u_projectionMatrix',\n    OFFSET_SCALE_MATRIX: 'u_offsetScaleMatrix',\n    OFFSET_ROTATION_MATRIX: 'u_offsetRotateMatrix',\n    TIME: 'u_time',\n    ZOOM: 'u_zoom',\n    RESOLUTION: 'u_resolution',\n};\n/**\n * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`\n * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.\n * @enum {number}\n */\nexport var AttributeType = {\n    UNSIGNED_BYTE: UNSIGNED_BYTE,\n    UNSIGNED_SHORT: UNSIGNED_SHORT,\n    UNSIGNED_INT: UNSIGNED_INT,\n    FLOAT: FLOAT,\n};\n/**\n * Description of an attribute in a buffer\n * @typedef {Object} AttributeDescription\n * @property {string} name Attribute name to use in shaders\n * @property {number} size Number of components per attributes\n * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is\n * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).\n * Default is `FLOAT`.\n */\n/**\n * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import(\"../transform\").Transform} UniformLiteralValue\n */\n/**\n * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning\n * one of the previous types.\n * @typedef {UniformLiteralValue|function(import(\"../PluggableMap.js\").FrameState):UniformLiteralValue} UniformValue\n */\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas which will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} Options\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform\n * names in the provided or default shaders.\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n * @property {string} [canvasCacheKey] The cache key for the canvas.\n */\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {string} name Name\n * @property {UniformValue} [value] Value\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n/**\n * @typedef {Object} CanvasCacheItem\n * @property {HTMLCanvasElement} canvas Canvas element.\n * @property {number} users The count of users of this canvas.\n */\n/**\n * @type {Object<string,CanvasCacheItem>}\n */\nvar canvasCache = {};\n/**\n * @param {string} key The cache key for the canvas.\n * @return {string} The shared cache key.\n */\nfunction getSharedCanvasCacheKey(key) {\n    return 'shared/' + key;\n}\nvar uniqueCanvasCacheKeyCount = 0;\n/**\n * @return {string} The unique cache key.\n */\nfunction getUniqueCanvasCacheKey() {\n    var key = 'unique/' + uniqueCanvasCacheKeyCount;\n    uniqueCanvasCacheKeyCount += 1;\n    return key;\n}\n/**\n * @param {string} key The cache key for the canvas.\n * @return {HTMLCanvasElement} The canvas.\n */\nfunction getCanvas(key) {\n    var cacheItem = canvasCache[key];\n    if (!cacheItem) {\n        var canvas = document.createElement('canvas');\n        canvas.style.position = 'absolute';\n        canvas.style.left = '0';\n        cacheItem = { users: 0, canvas: canvas };\n        canvasCache[key] = cacheItem;\n    }\n    cacheItem.users += 1;\n    return cacheItem.canvas;\n}\n/**\n * @param {string} key The cache key for the canvas.\n */\nfunction releaseCanvas(key) {\n    var cacheItem = canvasCache[key];\n    if (!cacheItem) {\n        return;\n    }\n    cacheItem.users -= 1;\n    if (cacheItem.users > 0) {\n        return;\n    }\n    var canvas = cacheItem.canvas;\n    var gl = getContext(canvas);\n    var extension = gl.getExtension('WEBGL_lose_context');\n    if (extension) {\n        extension.loseContext();\n    }\n    delete canvasCache[key];\n}\n/**\n * @classdesc\n * This class is intended to provide low-level functions related to WebGL rendering, so that accessing\n * directly the WebGL API should not be required anymore.\n *\n * Several operations are handled by the `WebGLHelper` class:\n *\n * ### Define custom shaders and uniforms\n *\n *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:\n *\n *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).\n *   Outputs are:\n *\n *   * `gl_Position`: position of the vertex in screen space\n *\n *   * Varyings usually prefixed with `v_` are passed on to the fragment shader\n *\n *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.\n *\n *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that\n *   can be changed at every frame and can be of type float, arrays of float or images.\n *\n *   Shaders must be compiled and assembled into a program like so:\n *   ```js\n *   // here we simply create two shaders and assemble them in a program which is then used\n *   // for subsequent rendering calls\n *   const vertexShader = new WebGLVertex(VERTEX_SHADER);\n *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);\n *   const program = this.context.getProgram(fragmentShader, vertexShader);\n *   helper.useProgram(this.program);\n *   ```\n *\n *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.\n *   You can also change their value along the way like so:\n *   ```js\n *   helper.setUniformFloatValue('u_value', valueAsNumber);\n *   ```\n *\n * ### Defining post processing passes\n *\n *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas\n *   while applying special effects in screen space.\n *   Typical uses are: blurring, color manipulation, depth of field, filtering...\n *\n *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.\n *   A post process step accepts the following options:\n *\n *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.\n *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.\n *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.\n *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.\n *\n *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.\n *\n * ### Binding WebGL buffers and flushing data into them\n *\n *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.\n *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.\n *   This is done using {@link bindBuffer}.\n *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using\n *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.\n *\n *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}\n *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).\n *\n *   Examples below:\n *   ```js\n *   // at initialization phase\n *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *\n *   // when array values have changed\n *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *\n *   // at rendering phase\n *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *   ```\n *\n * ### Specifying attributes\n *\n *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).\n *   Attributes are used to specify these uses. Specify the attribute names with\n *   {@link module:ol/webgl/Helper~WebGLHelper#enableAttributes enableAttributes()} (see code snippet below).\n *\n *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.\n *   ```js\n *   // here we indicate that the data array has the following structure:\n *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]\n *   helper.enableAttributes([\n *     {\n *        name: 'a_position',\n *        size: 2\n *     },\n *     {\n *       name: 'a_offset',\n *       size: 2\n *     },\n *     {\n *       name: 'a_texCoord',\n *       size: 2\n *     }\n *   ])\n *   ```\n *\n * ### Rendering primitives\n *\n *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.\n *   ```js\n *   // frame preparation step\n *   helper.prepareDraw(frameState);\n *\n *   // call this for every data array that has to be rendered on screen\n *   helper.drawElements(0, this.indicesBuffer.getArray().length);\n *\n *   // finalize the rendering by applying post processes\n *   helper.finalizeDraw(frameState);\n *   ```\n *\n * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @api\n */\nvar WebGLHelper = /** @class */ (function (_super) {\n    __extends(WebGLHelper, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function WebGLHelper(opt_options) {\n        var _this = _super.call(this) || this;\n        var options = opt_options || {};\n        /** @private */\n        _this.boundHandleWebGLContextLost_ = _this.handleWebGLContextLost.bind(_this);\n        /** @private */\n        _this.boundHandleWebGLContextRestored_ =\n            _this.handleWebGLContextRestored.bind(_this);\n        /**\n         * @private\n         * @type {string}\n         */\n        _this.canvasCacheKey_ = options.canvasCacheKey\n            ? getSharedCanvasCacheKey(options.canvasCacheKey)\n            : getUniqueCanvasCacheKey();\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n        _this.canvas_ = getCanvas(_this.canvasCacheKey_);\n        /**\n         * @private\n         * @type {WebGLRenderingContext}\n         */\n        _this.gl_ = getContext(_this.canvas_);\n        /**\n         * @private\n         * @type {!Object<string, BufferCacheEntry>}\n         */\n        _this.bufferCache_ = {};\n        /**\n         * @private\n         * @type {Object<string, Object>}\n         */\n        _this.extensionCache_ = {};\n        /**\n         * @private\n         * @type {WebGLProgram}\n         */\n        _this.currentProgram_ = null;\n        _this.canvas_.addEventListener(ContextEventType.LOST, _this.boundHandleWebGLContextLost_);\n        _this.canvas_.addEventListener(ContextEventType.RESTORED, _this.boundHandleWebGLContextRestored_);\n        /**\n         * @private\n         * @type {import(\"../transform.js\").Transform}\n         */\n        _this.offsetRotateMatrix_ = createTransform();\n        /**\n         * @private\n         * @type {import(\"../transform.js\").Transform}\n         */\n        _this.offsetScaleMatrix_ = createTransform();\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.tmpMat4_ = create();\n        /**\n         * @private\n         * @type {Object<string, WebGLUniformLocation>}\n         */\n        _this.uniformLocations_ = {};\n        /**\n         * @private\n         * @type {Object<string, number>}\n         */\n        _this.attribLocations_ = {};\n        /**\n         * Holds info about custom uniforms used in the post processing pass.\n         * If the uniform is a texture, the WebGL Texture object will be stored here.\n         * @type {Array<UniformInternalDescription>}\n         * @private\n         */\n        _this.uniforms_ = [];\n        if (options.uniforms) {\n            _this.setUniforms(options.uniforms);\n        }\n        var gl = _this.getGL();\n        /**\n         * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the\n         * options. If no post process was given, a default one is used (so as not to have to make an exception to\n         * the frame buffer logic).\n         * @type {Array<WebGLPostProcessingPass>}\n         * @private\n         */\n        _this.postProcessPasses_ = options.postProcesses\n            ? options.postProcesses.map(function (options) {\n                return new WebGLPostProcessingPass({\n                    webGlContext: gl,\n                    scaleRatio: options.scaleRatio,\n                    vertexShader: options.vertexShader,\n                    fragmentShader: options.fragmentShader,\n                    uniforms: options.uniforms,\n                });\n            })\n            : [new WebGLPostProcessingPass({ webGlContext: gl })];\n        /**\n         * @type {string|null}\n         * @private\n         */\n        _this.shaderCompileErrors_ = null;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.startTime_ = Date.now();\n        return _this;\n    }\n    /**\n     * @param {Object<string, UniformValue>} uniforms Uniform definitions.\n     */\n    WebGLHelper.prototype.setUniforms = function (uniforms) {\n        this.uniforms_ = [];\n        for (var name_1 in uniforms) {\n            this.uniforms_.push({\n                name: name_1,\n                value: uniforms[name_1],\n            });\n        }\n        this.uniformLocations_ = {};\n    };\n    /**\n     * @param {string} canvasCacheKey The canvas cache key.\n     * @return {boolean} The provided key matches the one this helper was constructed with.\n     */\n    WebGLHelper.prototype.canvasCacheKeyMatches = function (canvasCacheKey) {\n        return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);\n    };\n    /**\n     * Get a WebGL extension.  If the extension is not supported, null is returned.\n     * Extensions are cached after they are enabled for the first time.\n     * @param {string} name The extension name.\n     * @return {Object|null} The extension or null if not supported.\n     */\n    WebGLHelper.prototype.getExtension = function (name) {\n        if (name in this.extensionCache_) {\n            return this.extensionCache_[name];\n        }\n        var extension = this.gl_.getExtension(name);\n        this.extensionCache_[name] = extension;\n        return extension;\n    };\n    /**\n     * Just bind the buffer if it's in the cache. Otherwise create\n     * the WebGL buffer, bind it, populate it, and add an entry to\n     * the cache.\n     * @param {import(\"./Buffer\").default} buffer Buffer.\n     * @api\n     */\n    WebGLHelper.prototype.bindBuffer = function (buffer) {\n        var gl = this.getGL();\n        var bufferKey = getUid(buffer);\n        var bufferCache = this.bufferCache_[bufferKey];\n        if (!bufferCache) {\n            var webGlBuffer = gl.createBuffer();\n            bufferCache = {\n                buffer: buffer,\n                webGlBuffer: webGlBuffer,\n            };\n            this.bufferCache_[bufferKey] = bufferCache;\n        }\n        gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);\n    };\n    /**\n     * Update the data contained in the buffer array; this is required for the\n     * new data to be rendered\n     * @param {import(\"./Buffer\").default} buffer Buffer.\n     * @api\n     */\n    WebGLHelper.prototype.flushBufferData = function (buffer) {\n        var gl = this.getGL();\n        this.bindBuffer(buffer);\n        gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());\n    };\n    /**\n     * @param {import(\"./Buffer.js\").default} buf Buffer.\n     */\n    WebGLHelper.prototype.deleteBuffer = function (buf) {\n        var gl = this.getGL();\n        var bufferKey = getUid(buf);\n        var bufferCacheEntry = this.bufferCache_[bufferKey];\n        if (bufferCacheEntry && !gl.isContextLost()) {\n            gl.deleteBuffer(bufferCacheEntry.webGlBuffer);\n        }\n        delete this.bufferCache_[bufferKey];\n    };\n    /**\n     * Clean up.\n     */\n    WebGLHelper.prototype.disposeInternal = function () {\n        this.canvas_.removeEventListener(ContextEventType.LOST, this.boundHandleWebGLContextLost_);\n        this.canvas_.removeEventListener(ContextEventType.RESTORED, this.boundHandleWebGLContextRestored_);\n        releaseCanvas(this.canvasCacheKey_);\n        delete this.gl_;\n        delete this.canvas_;\n    };\n    /**\n     * Clear the buffer & set the viewport to draw.\n     * Post process passes will be initialized here, the first one being bound as a render target for\n     * subsequent draw calls.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n     * @param {boolean} [opt_disableAlphaBlend] If true, no alpha blending will happen.\n     * @api\n     */\n    WebGLHelper.prototype.prepareDraw = function (frameState, opt_disableAlphaBlend) {\n        var gl = this.getGL();\n        var canvas = this.getCanvas();\n        var size = frameState.size;\n        var pixelRatio = frameState.pixelRatio;\n        canvas.width = size[0] * pixelRatio;\n        canvas.height = size[1] * pixelRatio;\n        canvas.style.width = size[0] + 'px';\n        canvas.style.height = size[1] + 'px';\n        gl.useProgram(this.currentProgram_);\n        // loop backwards in post processes list\n        for (var i = this.postProcessPasses_.length - 1; i >= 0; i--) {\n            this.postProcessPasses_[i].init(frameState);\n        }\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.clearColor(0.0, 0.0, 0.0, 0.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n        gl.useProgram(this.currentProgram_);\n        this.applyFrameState(frameState);\n        this.applyUniforms(frameState);\n    };\n    /**\n     * Clear the render target & bind it for future draw operations.\n     * This is similar to `prepareDraw`, only post processes will not be applied.\n     * Note: the whole viewport will be drawn to the render target, regardless of its size.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n     * @param {import(\"./RenderTarget.js\").default} renderTarget Render target to draw to\n     * @param {boolean} [opt_disableAlphaBlend] If true, no alpha blending will happen.\n     */\n    WebGLHelper.prototype.prepareDrawToRenderTarget = function (frameState, renderTarget, opt_disableAlphaBlend) {\n        var gl = this.getGL();\n        var size = renderTarget.getSize();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());\n        gl.viewport(0, 0, size[0], size[1]);\n        gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());\n        gl.clearColor(0.0, 0.0, 0.0, 0.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n        gl.useProgram(this.currentProgram_);\n        this.applyFrameState(frameState);\n        this.applyUniforms(frameState);\n    };\n    /**\n     * Execute a draw call based on the currently bound program, texture, buffers, attributes.\n     * @param {number} start Start index.\n     * @param {number} end End index.\n     * @api\n     */\n    WebGLHelper.prototype.drawElements = function (start, end) {\n        var gl = this.getGL();\n        this.getExtension('OES_element_index_uint');\n        var elementType = gl.UNSIGNED_INT;\n        var elementSize = 4;\n        var numItems = end - start;\n        var offsetInBytes = start * elementSize;\n        gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);\n    };\n    /**\n     * Apply the successive post process passes which will eventually render to the actual canvas.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n     * @param {function(WebGLRenderingContext, import(\"../PluggableMap.js\").FrameState):void} [preCompose] Called before composing.\n     * @param {function(WebGLRenderingContext, import(\"../PluggableMap.js\").FrameState):void} [postCompose] Called before composing.\n     */\n    WebGLHelper.prototype.finalizeDraw = function (frameState, preCompose, postCompose) {\n        // apply post processes using the next one as target\n        for (var i = 0, ii = this.postProcessPasses_.length; i < ii; i++) {\n            if (i === ii - 1) {\n                this.postProcessPasses_[i].apply(frameState, null, preCompose, postCompose);\n            }\n            else {\n                this.postProcessPasses_[i].apply(frameState, this.postProcessPasses_[i + 1]);\n            }\n        }\n    };\n    /**\n     * @return {HTMLCanvasElement} Canvas.\n     * @api\n     */\n    WebGLHelper.prototype.getCanvas = function () {\n        return this.canvas_;\n    };\n    /**\n     * Get the WebGL rendering context\n     * @return {WebGLRenderingContext} The rendering context.\n     * @api\n     */\n    WebGLHelper.prototype.getGL = function () {\n        return this.gl_;\n    };\n    /**\n     * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLHelper.prototype.applyFrameState = function (frameState) {\n        var size = frameState.size;\n        var rotation = frameState.viewState.rotation;\n        var offsetScaleMatrix = resetTransform(this.offsetScaleMatrix_);\n        scaleTransform(offsetScaleMatrix, 2 / size[0], 2 / size[1]);\n        var offsetRotateMatrix = resetTransform(this.offsetRotateMatrix_);\n        if (rotation !== 0) {\n            rotateTransform(offsetRotateMatrix, -rotation);\n        }\n        this.setUniformMatrixValue(DefaultUniform.OFFSET_SCALE_MATRIX, fromTransform(this.tmpMat4_, offsetScaleMatrix));\n        this.setUniformMatrixValue(DefaultUniform.OFFSET_ROTATION_MATRIX, fromTransform(this.tmpMat4_, offsetRotateMatrix));\n        this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 0.001);\n        this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);\n        this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);\n    };\n    /**\n     * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLHelper.prototype.applyUniforms = function (frameState) {\n        var gl = this.getGL();\n        var value;\n        var textureSlot = 0;\n        this.uniforms_.forEach(function (uniform) {\n            value =\n                typeof uniform.value === 'function'\n                    ? uniform.value(frameState)\n                    : uniform.value;\n            // apply value based on type\n            if (value instanceof HTMLCanvasElement ||\n                value instanceof HTMLImageElement ||\n                value instanceof ImageData) {\n                // create a texture & put data\n                if (!uniform.texture) {\n                    uniform.prevValue = undefined;\n                    uniform.texture = gl.createTexture();\n                }\n                gl.activeTexture(gl[\"TEXTURE\".concat(textureSlot)]);\n                gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                var imageReady = !(value instanceof HTMLImageElement) ||\n                    /** @type {HTMLImageElement} */ (value).complete;\n                if (imageReady && uniform.prevValue !== value) {\n                    uniform.prevValue = value;\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);\n                }\n                // fill texture slots by increasing index\n                gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);\n            }\n            else if (Array.isArray(value) && value.length === 6) {\n                this.setUniformMatrixValue(uniform.name, fromTransform(this.tmpMat4_, value));\n            }\n            else if (Array.isArray(value) && value.length <= 4) {\n                switch (value.length) {\n                    case 2:\n                        gl.uniform2f(this.getUniformLocation(uniform.name), value[0], value[1]);\n                        return;\n                    case 3:\n                        gl.uniform3f(this.getUniformLocation(uniform.name), value[0], value[1], value[2]);\n                        return;\n                    case 4:\n                        gl.uniform4f(this.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);\n                        return;\n                    default:\n                        return;\n                }\n            }\n            else if (typeof value === 'number') {\n                gl.uniform1f(this.getUniformLocation(uniform.name), value);\n            }\n        }.bind(this));\n    };\n    /**\n     * Use a program.  If the program is already in use, this will return `false`.\n     * @param {WebGLProgram} program Program.\n     * @return {boolean} Changed.\n     * @api\n     */\n    WebGLHelper.prototype.useProgram = function (program) {\n        if (program == this.currentProgram_) {\n            return false;\n        }\n        else {\n            var gl = this.getGL();\n            gl.useProgram(program);\n            this.currentProgram_ = program;\n            this.uniformLocations_ = {};\n            this.attribLocations_ = {};\n            return true;\n        }\n    };\n    /**\n     * Will attempt to compile a vertex or fragment shader based on source\n     * On error, the shader will be returned but\n     * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`\n     * Use `gl.getShaderInfoLog(shader)` to have details\n     * @param {string} source Shader source\n     * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER\n     * @return {WebGLShader} Shader object\n     */\n    WebGLHelper.prototype.compileShader = function (source, type) {\n        var gl = this.getGL();\n        var shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        return shader;\n    };\n    /**\n     * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.\n     * @param {string} fragmentShaderSource Fragment shader source.\n     * @param {string} vertexShaderSource Vertex shader source.\n     * @return {WebGLProgram} Program\n     * @api\n     */\n    WebGLHelper.prototype.getProgram = function (fragmentShaderSource, vertexShaderSource) {\n        var gl = this.getGL();\n        var fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);\n        var vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);\n        var program = gl.createProgram();\n        gl.attachShader(program, fragmentShader);\n        gl.attachShader(program, vertexShader);\n        gl.linkProgram(program);\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n            var message = \"Fragment shader compliation failed: \".concat(gl.getShaderInfoLog(fragmentShader));\n            throw new Error(message);\n        }\n        gl.deleteShader(fragmentShader);\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n            var message = \"Vertex shader compilation failed: \".concat(gl.getShaderInfoLog(vertexShader));\n            throw new Error(message);\n        }\n        gl.deleteShader(vertexShader);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            var message = \"GL program linking failed: \".concat(gl.getShaderInfoLog(vertexShader));\n            throw new Error(message);\n        }\n        return program;\n    };\n    /**\n     * Will get the location from the shader or the cache\n     * @param {string} name Uniform name\n     * @return {WebGLUniformLocation} uniformLocation\n     * @api\n     */\n    WebGLHelper.prototype.getUniformLocation = function (name) {\n        if (this.uniformLocations_[name] === undefined) {\n            this.uniformLocations_[name] = this.getGL().getUniformLocation(this.currentProgram_, name);\n        }\n        return this.uniformLocations_[name];\n    };\n    /**\n     * Will get the location from the shader or the cache\n     * @param {string} name Attribute name\n     * @return {number} attribLocation\n     * @api\n     */\n    WebGLHelper.prototype.getAttributeLocation = function (name) {\n        if (this.attribLocations_[name] === undefined) {\n            this.attribLocations_[name] = this.getGL().getAttribLocation(this.currentProgram_, name);\n        }\n        return this.attribLocations_[name];\n    };\n    /**\n     * Modifies the given transform to apply the rotation/translation/scaling of the given frame state.\n     * The resulting transform can be used to convert world space coordinates to view coordinates.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {import(\"../transform\").Transform} transform Transform to update.\n     * @return {import(\"../transform\").Transform} The updated transform object.\n     * @api\n     */\n    WebGLHelper.prototype.makeProjectionTransform = function (frameState, transform) {\n        var size = frameState.size;\n        var rotation = frameState.viewState.rotation;\n        var resolution = frameState.viewState.resolution;\n        var center = frameState.viewState.center;\n        resetTransform(transform);\n        composeTransform(transform, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);\n        return transform;\n    };\n    /**\n     * Give a value for a standard float uniform\n     * @param {string} uniform Uniform name\n     * @param {number} value Value\n     * @api\n     */\n    WebGLHelper.prototype.setUniformFloatValue = function (uniform, value) {\n        this.getGL().uniform1f(this.getUniformLocation(uniform), value);\n    };\n    /**\n     * Give a value for a vec4 uniform\n     * @param {string} uniform Uniform name\n     * @param {Array<number>} value Array of length 4.\n     */\n    WebGLHelper.prototype.setUniformFloatVec4 = function (uniform, value) {\n        this.getGL().uniform4fv(this.getUniformLocation(uniform), value);\n    };\n    /**\n     * Give a value for a standard matrix4 uniform\n     * @param {string} uniform Uniform name\n     * @param {Array<number>} value Matrix value\n     * @api\n     */\n    WebGLHelper.prototype.setUniformMatrixValue = function (uniform, value) {\n        this.getGL().uniformMatrix4fv(this.getUniformLocation(uniform), false, value);\n    };\n    /**\n     * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`\n     * internally.\n     * @param {string} attribName Attribute name\n     * @param {number} size Number of components per attributes\n     * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT\n     * @param {number} stride Stride in bytes (0 means attribs are packed)\n     * @param {number} offset Offset in bytes\n     * @private\n     */\n    WebGLHelper.prototype.enableAttributeArray_ = function (attribName, size, type, stride, offset) {\n        var location = this.getAttributeLocation(attribName);\n        // the attribute has not been found in the shaders; do not enable it\n        if (location < 0) {\n            return;\n        }\n        this.getGL().enableVertexAttribArray(location);\n        this.getGL().vertexAttribPointer(location, size, type, false, stride, offset);\n    };\n    /**\n     * Will enable the following attributes to be read from the currently bound buffer,\n     * i.e. tell the GPU where to read the different attributes in the buffer. An error in the\n     * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.\n     * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer\n     * @api\n     */\n    WebGLHelper.prototype.enableAttributes = function (attributes) {\n        var stride = computeAttributesStride(attributes);\n        var offset = 0;\n        for (var i = 0; i < attributes.length; i++) {\n            var attr = attributes[i];\n            this.enableAttributeArray_(attr.name, attr.size, attr.type || FLOAT, stride, offset);\n            offset += attr.size * getByteSizeFromType(attr.type);\n        }\n    };\n    /**\n     * WebGL context was lost\n     * @private\n     */\n    WebGLHelper.prototype.handleWebGLContextLost = function () {\n        clear(this.bufferCache_);\n        this.currentProgram_ = null;\n    };\n    /**\n     * WebGL context was restored\n     * @private\n     */\n    WebGLHelper.prototype.handleWebGLContextRestored = function () { };\n    /**\n     * Will create or reuse a given webgl texture and apply the given size. If no image data\n     * specified, the texture will be empty, otherwise image data will be used and the `size`\n     * parameter will be ignored.\n     * Note: wrap parameters are set to clamp to edge, min filter is set to linear.\n     * @param {Array<number>} size Expected size of the texture\n     * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [opt_data] Image data/object to bind to the texture\n     * @param {WebGLTexture} [opt_texture] Existing texture to reuse\n     * @return {WebGLTexture} The generated texture\n     * @api\n     */\n    WebGLHelper.prototype.createTexture = function (size, opt_data, opt_texture) {\n        var gl = this.getGL();\n        var texture = opt_texture || gl.createTexture();\n        // set params & size\n        var level = 0;\n        var internalFormat = gl.RGBA;\n        var border = 0;\n        var format = gl.RGBA;\n        var type = gl.UNSIGNED_BYTE;\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        if (opt_data) {\n            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, opt_data);\n        }\n        else {\n            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format, type, null);\n        }\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        return texture;\n    };\n    return WebGLHelper;\n}(Disposable));\n/**\n * Compute a stride in bytes based on a list of attributes\n * @param {Array<AttributeDescription>} attributes Ordered list of attributes\n * @return {number} Stride, ie amount of values for each vertex in the vertex buffer\n * @api\n */\nexport function computeAttributesStride(attributes) {\n    var stride = 0;\n    for (var i = 0; i < attributes.length; i++) {\n        var attr = attributes[i];\n        stride += attr.size * getByteSizeFromType(attr.type);\n    }\n    return stride;\n}\n/**\n * Computes the size in byte of an attribute type.\n * @param {AttributeType} type Attribute type\n * @return {number} The size in bytes\n */\nfunction getByteSizeFromType(type) {\n    switch (type) {\n        case AttributeType.UNSIGNED_BYTE:\n            return Uint8Array.BYTES_PER_ELEMENT;\n        case AttributeType.UNSIGNED_SHORT:\n            return Uint16Array.BYTES_PER_ELEMENT;\n        case AttributeType.UNSIGNED_INT:\n            return Uint32Array.BYTES_PER_ELEMENT;\n        case AttributeType.FLOAT:\n        default:\n            return Float32Array.BYTES_PER_ELEMENT;\n    }\n}\nexport default WebGLHelper;\n//# sourceMappingURL=Helper.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerProperty from '../../layer/Property.js';\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, } from '../../transform.js';\nimport { containsCoordinate } from '../../extent.js';\n/**\n * @enum {string}\n */\nexport var WebGLWorkerMessageType = {\n    GENERATE_BUFFERS: 'GENERATE_BUFFERS',\n};\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.\n */\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} Options\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nvar WebGLLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLLayerRenderer, _super);\n    /**\n     * @param {LayerType} layer Layer.\n     * @param {Options} [opt_options] Options.\n     */\n    function WebGLLayerRenderer(layer, opt_options) {\n        var _this = _super.call(this, layer) || this;\n        var options = opt_options || {};\n        /**\n         * The transform for viewport CSS pixels to rendered pixels.  This transform is only\n         * set before dispatching rendering events.\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n        _this.inversePixelTransform_ = createTransform();\n        /**\n         * @private\n         * @type {CanvasRenderingContext2D}\n         */\n        _this.pixelContext_ = null;\n        /**\n         * @private\n         */\n        _this.postProcesses_ = options.postProcesses;\n        /**\n         * @private\n         */\n        _this.uniforms_ = options.uniforms;\n        /**\n         * @type {WebGLHelper}\n         * @protected\n         */\n        _this.helper;\n        layer.addChangeListener(LayerProperty.MAP, _this.removeHelper.bind(_this));\n        _this.dispatchPreComposeEvent = _this.dispatchPreComposeEvent.bind(_this);\n        _this.dispatchPostComposeEvent = _this.dispatchPostComposeEvent.bind(_this);\n        return _this;\n    }\n    /**\n     * @param {WebGLRenderingContext} context The WebGL rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.dispatchPreComposeEvent = function (context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n            var event_1 = new RenderEvent(RenderEventType.PRECOMPOSE, undefined, frameState, context);\n            layer.dispatchEvent(event_1);\n        }\n    };\n    /**\n     * @param {WebGLRenderingContext} context The WebGL rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.dispatchPostComposeEvent = function (context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n            var event_2 = new RenderEvent(RenderEventType.POSTCOMPOSE, undefined, frameState, context);\n            layer.dispatchEvent(event_2);\n        }\n    };\n    /**\n     * Reset options (only handles uniforms).\n     * @param {Options} options Options.\n     */\n    WebGLLayerRenderer.prototype.reset = function (options) {\n        this.uniforms_ = options.uniforms;\n        if (this.helper) {\n            this.helper.setUniforms(this.uniforms_);\n        }\n    };\n    /**\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.removeHelper = function () {\n        if (this.helper) {\n            this.helper.dispose();\n            delete this.helper;\n        }\n    };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLLayerRenderer.prototype.prepareFrame = function (frameState) {\n        if (this.getLayer().getRenderSource()) {\n            var incrementGroup = true;\n            var groupNumber = -1;\n            var className = void 0;\n            for (var i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\n                var layer = frameState.layerStatesArray[i].layer;\n                var renderer = layer.getRenderer();\n                if (!(renderer instanceof WebGLLayerRenderer)) {\n                    incrementGroup = true;\n                    continue;\n                }\n                var layerClassName = layer.getClassName();\n                if (incrementGroup || layerClassName !== className) {\n                    groupNumber += 1;\n                    incrementGroup = false;\n                }\n                className = layerClassName;\n                if (renderer === this) {\n                    break;\n                }\n            }\n            var canvasCacheKey = 'map/' + frameState.mapId + '/group/' + groupNumber;\n            if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {\n                this.removeHelper();\n                this.helper = new WebGLHelper({\n                    postProcesses: this.postProcesses_,\n                    uniforms: this.uniforms_,\n                    canvasCacheKey: canvasCacheKey,\n                });\n                if (className) {\n                    this.helper.getCanvas().className = className;\n                }\n                this.afterHelperCreated();\n            }\n        }\n        return this.prepareFrameInternal(frameState);\n    };\n    /**\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.afterHelperCreated = function () { };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.prepareFrameInternal = function (frameState) {\n        return true;\n    };\n    /**\n     * Clean up.\n     */\n    WebGLLayerRenderer.prototype.disposeInternal = function () {\n        this.removeHelper();\n        _super.prototype.disposeInternal.call(this);\n    };\n    /**\n     * @param {import(\"../../render/EventType.js\").default} type Event type.\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLLayerRenderer.prototype.dispatchRenderEvent_ = function (type, context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(type)) {\n            composeTransform(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);\n            var event_3 = new RenderEvent(type, this.inversePixelTransform_, frameState, context);\n            layer.dispatchEvent(event_3);\n        }\n    };\n    /**\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.preRender = function (context, frameState) {\n        this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n    };\n    /**\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.postRender = function (context, frameState) {\n        this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n    };\n    /**\n     * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState FrameState.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel\n     *    location, null will be returned.  If there is data, but pixel values cannot be\n     *    returned, and empty array will be returned.\n     */\n    WebGLLayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {\n        var renderPixel = applyTransform([frameState.pixelRatio, 0, 0, frameState.pixelRatio, 0, 0], pixel.slice());\n        var gl = this.helper.getGL();\n        if (!gl) {\n            return null;\n        }\n        var layer = this.getLayer();\n        var layerExtent = layer.getExtent();\n        if (layerExtent) {\n            var renderCoordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n            /** get only data inside of the layer extent */\n            if (!containsCoordinate(layerExtent, renderCoordinate)) {\n                return null;\n            }\n        }\n        var attributes = gl.getContextAttributes();\n        if (!attributes || !attributes.preserveDrawingBuffer) {\n            // we assume there is data at the given pixel (although there might not be)\n            return new Uint8Array();\n        }\n        var x = Math.round(renderPixel[0]);\n        var y = Math.round(renderPixel[1]);\n        var pixelContext = this.pixelContext_;\n        if (!pixelContext) {\n            var pixelCanvas = document.createElement('canvas');\n            pixelCanvas.width = 1;\n            pixelCanvas.height = 1;\n            pixelContext = pixelCanvas.getContext('2d');\n            this.pixelContext_ = pixelContext;\n        }\n        pixelContext.clearRect(0, 0, 1, 1);\n        var data;\n        try {\n            pixelContext.drawImage(gl.canvas, x, y, 1, 1, 0, 0, 1, 1);\n            data = pixelContext.getImageData(0, 0, 1, 1).data;\n        }\n        catch (err) {\n            return data;\n        }\n        if (data[3] === 0) {\n            return null;\n        }\n        return data;\n    };\n    return WebGLLayerRenderer;\n}(LayerRenderer));\nvar tmpArray_ = [];\nvar bufferPositions_ = { vertexPosition: 0, indexPosition: 0 };\nfunction writePointVertex(buffer, pos, x, y, index) {\n    buffer[pos + 0] = x;\n    buffer[pos + 1] = y;\n    buffer[pos + 2] = index;\n}\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {\n    // This is for x, y and index\n    var baseVertexAttrsCount = 3;\n    var baseInstructionsCount = 2;\n    var stride = baseVertexAttrsCount + customAttributesCount;\n    var x = instructions[elementIndex + 0];\n    var y = instructions[elementIndex + 1];\n    // read custom numerical attributes on the feature\n    var customAttrs = tmpArray_;\n    customAttrs.length = customAttributesCount;\n    for (var i = 0; i < customAttrs.length; i++) {\n        customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n    }\n    var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n    var iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n    var baseIndex = vPos / stride;\n    // push vertices for each of the four quad corners (first standard then custom attributes)\n    writePointVertex(vertexBuffer, vPos, x, y, 0);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 1);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 2);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 3);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    indexBuffer[iPos++] = baseIndex;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 3;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 2;\n    indexBuffer[iPos++] = baseIndex + 3;\n    bufferPositions_.vertexPosition = vPos;\n    bufferPositions_.indexPosition = iPos;\n    return bufferPositions_;\n}\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n    var canvas = document.createElement('canvas');\n    var image = canvas.getContext('2d').createImageData(1, 1);\n    image.data[0] = 255;\n    image.data[1] = 255;\n    image.data[2] = 255;\n    image.data[3] = 255;\n    return image;\n}\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [opt_array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, opt_array) {\n    var array = opt_array || [];\n    var radix = 256;\n    var divide = radix - 1;\n    array[0] = Math.floor(id / radix / radix / radix) / divide;\n    array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n    array[2] = (Math.floor(id / radix) % radix) / divide;\n    array[3] = (id % radix) / divide;\n    return array;\n}\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n    var id = 0;\n    var radix = 256;\n    var mult = radix - 1;\n    id += Math.round(color[0] * radix * radix * radix * mult);\n    id += Math.round(color[1] * radix * radix * mult);\n    id += Math.round(color[2] * radix * mult);\n    id += Math.round(color[3] * mult);\n    return id;\n}\nexport default WebGLLayerRenderer;\n//# sourceMappingURL=Layer.js.map","/**\n * A wrapper class to simplify rendering to a texture instead of the final canvas\n * @module ol/webgl/RenderTarget\n */\nimport { equals } from '../array.js';\n// for pixel color reading\nvar tmpArray4 = new Uint8Array(4);\n/**\n * @classdesc\n * This class is a wrapper around the association of both a `WebGLTexture` and a `WebGLFramebuffer` instances,\n * simplifying initialization and binding for rendering.\n * @api\n */\nvar WebGLRenderTarget = /** @class */ (function () {\n    /**\n     * @param {import(\"./Helper.js\").default} helper WebGL helper; mandatory.\n     * @param {Array<number>} [opt_size] Expected size of the render target texture; note: this can be changed later on.\n     */\n    function WebGLRenderTarget(helper, opt_size) {\n        /**\n         * @private\n         * @type {import(\"./Helper.js\").default}\n         */\n        this.helper_ = helper;\n        var gl = helper.getGL();\n        /**\n         * @private\n         * @type {WebGLTexture}\n         */\n        this.texture_ = gl.createTexture();\n        /**\n         * @private\n         * @type {WebGLFramebuffer}\n         */\n        this.framebuffer_ = gl.createFramebuffer();\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        this.size_ = opt_size || [1, 1];\n        /**\n         * @type {Uint8Array}\n         * @private\n         */\n        this.data_ = new Uint8Array(0);\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.dataCacheDirty_ = true;\n        this.updateSize_();\n    }\n    /**\n     * Changes the size of the render target texture. Note: will do nothing if the size\n     * is already the same.\n     * @param {Array<number>} size Expected size of the render target texture\n     * @api\n     */\n    WebGLRenderTarget.prototype.setSize = function (size) {\n        if (equals(size, this.size_)) {\n            return;\n        }\n        this.size_[0] = size[0];\n        this.size_[1] = size[1];\n        this.updateSize_();\n    };\n    /**\n     * Returns the size of the render target texture\n     * @return {Array<number>} Size of the render target texture\n     * @api\n     */\n    WebGLRenderTarget.prototype.getSize = function () {\n        return this.size_;\n    };\n    /**\n     * This will cause following calls to `#readAll` or `#readPixel` to download the content of the\n     * render target into memory, which is an expensive operation.\n     * This content will be kept in cache but should be cleared after each new render.\n     * @api\n     */\n    WebGLRenderTarget.prototype.clearCachedData = function () {\n        this.dataCacheDirty_ = true;\n    };\n    /**\n     * Returns the full content of the frame buffer as a series of r, g, b, a components\n     * in the 0-255 range (unsigned byte).\n     * @return {Uint8Array} Integer array of color values\n     * @api\n     */\n    WebGLRenderTarget.prototype.readAll = function () {\n        if (this.dataCacheDirty_) {\n            var size = this.size_;\n            var gl = this.helper_.getGL();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);\n            gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.UNSIGNED_BYTE, this.data_);\n            this.dataCacheDirty_ = false;\n        }\n        return this.data_;\n    };\n    /**\n     * Reads one pixel of the frame buffer as an array of r, g, b, a components\n     * in the 0-255 range (unsigned byte).\n     * If x and/or y are outside of existing data, an array filled with 0 is returned.\n     * @param {number} x Pixel coordinate\n     * @param {number} y Pixel coordinate\n     * @return {Uint8Array} Integer array with one color value (4 components)\n     * @api\n     */\n    WebGLRenderTarget.prototype.readPixel = function (x, y) {\n        if (x < 0 || y < 0 || x > this.size_[0] || y >= this.size_[1]) {\n            tmpArray4[0] = 0;\n            tmpArray4[1] = 0;\n            tmpArray4[2] = 0;\n            tmpArray4[3] = 0;\n            return tmpArray4;\n        }\n        this.readAll();\n        var index = Math.floor(x) + (this.size_[1] - Math.floor(y) - 1) * this.size_[0];\n        tmpArray4[0] = this.data_[index * 4];\n        tmpArray4[1] = this.data_[index * 4 + 1];\n        tmpArray4[2] = this.data_[index * 4 + 2];\n        tmpArray4[3] = this.data_[index * 4 + 3];\n        return tmpArray4;\n    };\n    /**\n     * @return {WebGLTexture} Texture to render to\n     */\n    WebGLRenderTarget.prototype.getTexture = function () {\n        return this.texture_;\n    };\n    /**\n     * @return {WebGLFramebuffer} Frame buffer of the render target\n     */\n    WebGLRenderTarget.prototype.getFramebuffer = function () {\n        return this.framebuffer_;\n    };\n    /**\n     * @private\n     */\n    WebGLRenderTarget.prototype.updateSize_ = function () {\n        var size = this.size_;\n        var gl = this.helper_.getGL();\n        this.texture_ = this.helper_.createTexture(size, null, this.texture_);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);\n        gl.viewport(0, 0, size[0], size[1]);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture_, 0);\n        this.data_ = new Uint8Array(size[0] * size[1] * 4);\n    };\n    return WebGLRenderTarget;\n}());\nexport default WebGLRenderTarget;\n//# sourceMappingURL=RenderTarget.js.map","export function create() {\n    var source = \"var e=\\\"function\\\"==typeof Object.assign?Object.assign:function(e,n){if(null==e)throw new TypeError(\\\"Cannot convert undefined or null to object\\\");for(var t=Object(e),r=1,o=arguments.length;r<o;++r){var i=arguments[r];if(null!=i)for(var f in i)i.hasOwnProperty(f)&&(t[f]=i[f])}return t},n=\\\"GENERATE_BUFFERS\\\",t=[],r={vertexPosition:0,indexPosition:0};function o(e,n,t,r,o){e[n+0]=t,e[n+1]=r,e[n+2]=o}function i(e,n,i,f,s,a){var u=3+s,l=e[n+0],v=e[n+1],c=t;c.length=s;for(var g=0;g<c.length;g++)c[g]=e[n+2+g];var b=a?a.vertexPosition:0,h=a?a.indexPosition:0,d=b/u;return o(i,b,l,v,0),c.length&&i.set(c,b+3),o(i,b+=u,l,v,1),c.length&&i.set(c,b+3),o(i,b+=u,l,v,2),c.length&&i.set(c,b+3),o(i,b+=u,l,v,3),c.length&&i.set(c,b+3),b+=u,f[h++]=d,f[h++]=d+1,f[h++]=d+3,f[h++]=d+1,f[h++]=d+2,f[h++]=d+3,r.vertexPosition=b,r.indexPosition=h,r}var f=self;f.onmessage=function(t){var r=t.data;if(r.type===n){for(var o,s=r.customAttributesCount,a=2+s,u=new Float32Array(r.renderInstructions),l=u.length/a,v=4*l*(s+3),c=new Uint32Array(6*l),g=new Float32Array(v),b=0;b<u.length;b+=a)o=i(u,b,g,c,s,o);var h=e({vertexBuffer:g.buffer,indexBuffer:c.buffer,renderInstructions:u.buffer},r);f.postMessage(h,[g.buffer,c.buffer,u.buffer])}};\";\n    return new Worker(typeof Blob === 'undefined'\n        ? 'data:application/javascript;base64,' + Buffer.from(source, 'binary').toString('base64')\n        : URL.createObjectURL(new Blob([source], { type: 'application/javascript' })));\n}\n//# sourceMappingURL=webgl.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer, { WebGLWorkerMessageType, colorDecodeId, colorEncodeId, } from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER } from '../../webgl.js';\nimport { AttributeType, DefaultUniform } from '../../webgl/Helper.js';\nimport { apply as applyTransform, create as createTransform, makeInverse as makeInverseTransform, multiply as multiplyTransform, } from '../../transform.js';\nimport { assert } from '../../asserts.js';\nimport { buffer, createEmpty, equals } from '../../extent.js';\nimport { create as createWebGLWorker } from '../../worker/webgl.js';\nimport { getUid } from '../../util.js';\nimport { listen, unlistenByKey } from '../../events.js';\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nvar WebGLPointsLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLPointsLayerRenderer, _super);\n    /**\n     * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n     * @param {Options} options Options.\n     */\n    function WebGLPointsLayerRenderer(layer, options) {\n        var _this = this;\n        var uniforms = options.uniforms || {};\n        var projectionMatrixTransform = createTransform();\n        uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n        _this = _super.call(this, layer, {\n            uniforms: uniforms,\n            postProcesses: options.postProcesses,\n        }) || this;\n        _this.ready = false;\n        _this.sourceRevision_ = -1;\n        _this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.indicesBuffer_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);\n        /**\n         * @private\n         */\n        _this.vertexShader_ = options.vertexShader;\n        /**\n         * @private\n         */\n        _this.fragmentShader_ = options.fragmentShader;\n        /**\n         * @type {WebGLProgram}\n         * @private\n         */\n        _this.program_;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.hitDetectionEnabled_ =\n            options.hitFragmentShader && options.hitVertexShader ? true : false;\n        /**\n         * @private\n         */\n        _this.hitVertexShader_ = options.hitVertexShader;\n        /**\n         * @private\n         */\n        _this.hitFragmentShader_ = options.hitFragmentShader;\n        /**\n         * @type {WebGLProgram}\n         * @private\n         */\n        _this.hitProgram_;\n        var customAttributes = options.attributes\n            ? options.attributes.map(function (attribute) {\n                return {\n                    name: 'a_' + attribute.name,\n                    size: 1,\n                    type: AttributeType.FLOAT,\n                };\n            })\n            : [];\n        /**\n         * A list of attributes used by the renderer. By default only the position and\n         * index of the vertex (0 to 3) are required.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.attributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        /**\n         * A list of attributes used for hit detection.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.hitDetectionAttributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_hitColor',\n                size: 4,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_featureUid',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        _this.customAttributes = options.attributes ? options.attributes : [];\n        _this.previousExtent_ = createEmpty();\n        /**\n         * This transform is updated on every frame and is the composition of:\n         * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n         * - current world->screen transform\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.currentTransform_ = projectionMatrixTransform;\n        /**\n         * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.renderTransform_ = createTransform();\n        /**\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.invertRenderTransform_ = createTransform();\n        /**\n         * @type {Float32Array}\n         * @private\n         */\n        _this.renderInstructions_ = new Float32Array(0);\n        /**\n         * These instructions are used for hit detection\n         * @type {Float32Array}\n         * @private\n         */\n        _this.hitRenderInstructions_ = new Float32Array(0);\n        /**\n         * @type {WebGLRenderTarget}\n         * @private\n         */\n        _this.hitRenderTarget_;\n        /**\n         * Keep track of latest message sent to worker\n         * @type {number}\n         * @private\n         */\n        _this.generateBuffersRun_ = 0;\n        _this.worker_ = createWebGLWorker();\n        _this.worker_.addEventListener('message', \n        /**\n         * @param {*} event Event.\n         * @this {WebGLPointsLayerRenderer}\n         */\n        function (event) {\n            var received = event.data;\n            if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {\n                var projectionTransform = received.projectionTransform;\n                if (received.hitDetection) {\n                    this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.hitVerticesBuffer_);\n                }\n                else {\n                    this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.verticesBuffer_);\n                }\n                this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n                this.helper.flushBufferData(this.indicesBuffer_);\n                this.renderTransform_ = projectionTransform;\n                makeInverseTransform(this.invertRenderTransform_, this.renderTransform_);\n                if (received.hitDetection) {\n                    this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);\n                }\n                else {\n                    this.renderInstructions_ = new Float32Array(event.data.renderInstructions);\n                    if (received.generateBuffersRun === this.generateBuffersRun_) {\n                        this.ready = true;\n                    }\n                }\n                this.getLayer().changed();\n            }\n        }.bind(_this));\n        /**\n         * This object will be updated when the source changes. Key is uid.\n         * @type {Object<string, FeatureCacheItem>}\n         * @private\n         */\n        _this.featureCache_ = {};\n        /**\n         * Amount of features in the cache.\n         * @type {number}\n         * @private\n         */\n        _this.featureCount_ = 0;\n        var source = _this.getLayer().getSource();\n        _this.sourceListenKeys_ = [\n            listen(source, VectorEventType.ADDFEATURE, _this.handleSourceFeatureAdded_, _this),\n            listen(source, VectorEventType.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this),\n            listen(source, VectorEventType.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this),\n            listen(source, VectorEventType.CLEAR, _this.handleSourceFeatureClear_, _this),\n        ];\n        source.forEachFeature(function (feature) {\n            this.featureCache_[getUid(feature)] = {\n                feature: feature,\n                properties: feature.getProperties(),\n                geometry: feature.getGeometry(),\n            };\n            this.featureCount_++;\n        }.bind(_this));\n        return _this;\n    }\n    WebGLPointsLayerRenderer.prototype.afterHelperCreated = function () {\n        this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n        if (this.hitDetectionEnabled_) {\n            this.hitProgram_ = this.helper.getProgram(this.hitFragmentShader_, this.hitVertexShader_);\n            this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n        }\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureAdded_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n        this.featureCount_++;\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureChanged_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureDelete_ = function (event) {\n        var feature = event.feature;\n        delete this.featureCache_[getUid(feature)];\n        this.featureCount_--;\n    };\n    /**\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureClear_ = function () {\n        this.featureCache_ = {};\n        this.featureCount_ = 0;\n    };\n    /**\n     * Render the layer.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {HTMLElement} The rendered element.\n     */\n    WebGLPointsLayerRenderer.prototype.renderFrame = function (frameState) {\n        var gl = this.helper.getGL();\n        this.preRender(gl, frameState);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n        this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n        var canvas = this.helper.getCanvas();\n        if (this.hitDetectionEnabled_) {\n            this.renderHitDetection(frameState);\n            this.hitRenderTarget_.clearCachedData();\n        }\n        this.postRender(gl, frameState);\n        return canvas;\n    };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLPointsLayerRenderer.prototype.prepareFrameInternal = function (frameState) {\n        var layer = this.getLayer();\n        var vectorSource = layer.getSource();\n        var viewState = frameState.viewState;\n        var viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] &&\n            !frameState.viewHints[ViewHint.INTERACTING];\n        var extentChanged = !equals(this.previousExtent_, frameState.extent);\n        var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n        if (sourceChanged) {\n            this.sourceRevision_ = vectorSource.getRevision();\n        }\n        if (viewNotMoving && (extentChanged || sourceChanged)) {\n            var projection = viewState.projection;\n            var resolution = viewState.resolution;\n            var renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n            var extent = buffer(frameState.extent, renderBuffer * resolution);\n            vectorSource.loadFeatures(extent, resolution, projection);\n            this.rebuildBuffers_(frameState);\n            this.previousExtent_ = frameState.extent.slice();\n        }\n        // apply the current projection transform with the invert of the one used to fill buffers\n        this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n        multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n        this.helper.useProgram(this.program_);\n        this.helper.prepareDraw(frameState);\n        // write new data\n        this.helper.bindBuffer(this.verticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.attributes);\n        return true;\n    };\n    /**\n     * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n     * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.rebuildBuffers_ = function (frameState) {\n        // saves the projection transform for the current frame state\n        var projectionTransform = createTransform();\n        this.helper.makeProjectionTransform(frameState, projectionTransform);\n        // here we anticipate the amount of render instructions that we well generate\n        // this can be done since we know that for normal render we only have x, y as base instructions,\n        // and x, y, r, g, b, a and featureUid for hit render instructions\n        // and we also know the amount of custom attributes to append to these\n        var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;\n        if (!this.renderInstructions_ ||\n            this.renderInstructions_.length !== totalInstructionsCount) {\n            this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n        }\n        if (this.hitDetectionEnabled_) {\n            var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;\n            if (!this.hitRenderInstructions_ ||\n                this.hitRenderInstructions_.length !== totalHitInstructionsCount) {\n                this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);\n            }\n        }\n        // loop on features to fill the buffer\n        var featureCache, geometry;\n        var tmpCoords = [];\n        var tmpColor = [];\n        var renderIndex = 0;\n        var hitIndex = 0;\n        var hitColor;\n        for (var featureUid in this.featureCache_) {\n            featureCache = this.featureCache_[featureUid];\n            geometry = /** @type {import(\"../../geom\").Point} */ (featureCache.geometry);\n            if (!geometry || geometry.getType() !== GeometryType.POINT) {\n                continue;\n            }\n            tmpCoords[0] = geometry.getFlatCoordinates()[0];\n            tmpCoords[1] = geometry.getFlatCoordinates()[1];\n            applyTransform(projectionTransform, tmpCoords);\n            hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n            this.renderInstructions_[renderIndex++] = tmpCoords[0];\n            this.renderInstructions_[renderIndex++] = tmpCoords[1];\n            // for hit detection, the feature uid is saved in the opacity value\n            // and the index of the opacity value is encoded in the color values\n            if (this.hitDetectionEnabled_) {\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n                this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n            }\n            // pushing custom attributes\n            var value = void 0;\n            for (var j = 0; j < this.customAttributes.length; j++) {\n                value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);\n                this.renderInstructions_[renderIndex++] = value;\n                if (this.hitDetectionEnabled_) {\n                    this.hitRenderInstructions_[hitIndex++] = value;\n                }\n            }\n        }\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        var message = {\n            type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n            renderInstructions: this.renderInstructions_.buffer,\n            customAttributesCount: this.customAttributes.length,\n        };\n        // additional properties will be sent back as-is by the worker\n        message['projectionTransform'] = projectionTransform;\n        message['generateBuffersRun'] = ++this.generateBuffersRun_;\n        this.ready = false;\n        this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n        this.renderInstructions_ = null;\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        if (this.hitDetectionEnabled_) {\n            var hitMessage = {\n                type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n                renderInstructions: this.hitRenderInstructions_.buffer,\n                customAttributesCount: 5 + this.customAttributes.length,\n            };\n            hitMessage['projectionTransform'] = projectionTransform;\n            hitMessage['hitDetection'] = true;\n            this.worker_.postMessage(hitMessage, [\n                this.hitRenderInstructions_.buffer,\n            ]);\n            this.hitRenderInstructions_ = null;\n        }\n    };\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    WebGLPointsLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n        assert(this.hitDetectionEnabled_, 66);\n        if (!this.hitRenderInstructions_) {\n            return undefined;\n        }\n        var pixel = applyTransform(frameState.coordinateToPixelTransform, coordinate.slice());\n        var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n        var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n        var index = colorDecodeId(color);\n        var opacity = this.hitRenderInstructions_[index];\n        var uid = Math.floor(opacity).toString();\n        var source = this.getLayer().getSource();\n        var feature = source.getFeatureByUid(uid);\n        if (feature) {\n            return callback(feature, this.getLayer(), null);\n        }\n        return undefined;\n    };\n    /**\n     * Render the hit detection data to the corresponding render target\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState current frame state\n     */\n    WebGLPointsLayerRenderer.prototype.renderHitDetection = function (frameState) {\n        // skip render entirely if vertex buffers not ready/generated yet\n        if (!this.hitVerticesBuffer_.getSize()) {\n            return;\n        }\n        this.hitRenderTarget_.setSize([\n            Math.floor(frameState.size[0] / 2),\n            Math.floor(frameState.size[1] / 2),\n        ]);\n        this.helper.useProgram(this.hitProgram_);\n        this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);\n        this.helper.bindBuffer(this.hitVerticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.hitDetectionAttributes);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n    };\n    /**\n     * Clean up.\n     */\n    WebGLPointsLayerRenderer.prototype.disposeInternal = function () {\n        this.worker_.terminate();\n        this.layer_ = null;\n        this.sourceListenKeys_.forEach(function (key) {\n            unlistenByKey(key);\n        });\n        this.sourceListenKeys_ = null;\n        _super.prototype.disposeInternal.call(this);\n    };\n    return WebGLPointsLayerRenderer;\n}(WebGLLayerRenderer));\nexport default WebGLPointsLayerRenderer;\n//# sourceMappingURL=PointsLayer.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/layer/Heatmap\n */\nimport BaseVector from './BaseVector.js';\nimport WebGLPointsLayerRenderer from '../renderer/webgl/PointsLayer.js';\nimport { assign } from '../obj.js';\nimport { clamp } from '../math.js';\nimport { createCanvasContext2D } from '../dom.js';\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {Array<string>} [gradient=['#00f', '#0ff', '#0f0', '#ff0', '#f00']] The color gradient\n * of the heatmap, specified as an array of CSS color strings.\n * @property {number} [radius=8] Radius size in pixels.\n * @property {number} [blur=15] Blur size in pixels.\n * @property {string|function(import(\"../Feature.js\").default):number} [weight='weight'] The feature\n * attribute to use for the weight or a function that returns a weight from a feature. Weight values\n * should range from 0 to 1 (and values outside will be clamped to that range).\n * @property {import(\"../source/Vector.js\").default<import(\"../geom/Point.js\").default>} [source] Point source.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n/**\n * @enum {string}\n * @private\n */\nvar Property = {\n    BLUR: 'blur',\n    GRADIENT: 'gradient',\n    RADIUS: 'radius',\n};\n/**\n * @const\n * @type {Array<string>}\n */\nvar DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];\n/**\n * @classdesc\n * Layer for rendering vector data as a heatmap.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @extends {BaseVector<import(\"../source/Vector.js\").default, WebGLPointsLayerRenderer>}\n * @api\n */\nvar Heatmap = /** @class */ (function (_super) {\n    __extends(Heatmap, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function Heatmap(opt_options) {\n        var _this = this;\n        var options = opt_options ? opt_options : {};\n        var baseOptions = assign({}, options);\n        delete baseOptions.gradient;\n        delete baseOptions.radius;\n        delete baseOptions.blur;\n        delete baseOptions.weight;\n        _this = _super.call(this, baseOptions) || this;\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n        _this.gradient_ = null;\n        _this.addChangeListener(Property.GRADIENT, _this.handleGradientChanged_);\n        _this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);\n        _this.setBlur(options.blur !== undefined ? options.blur : 15);\n        _this.setRadius(options.radius !== undefined ? options.radius : 8);\n        var weight = options.weight ? options.weight : 'weight';\n        if (typeof weight === 'string') {\n            _this.weightFunction_ = function (feature) {\n                return feature.get(weight);\n            };\n        }\n        else {\n            _this.weightFunction_ = weight;\n        }\n        // For performance reasons, don't sort the features before rendering.\n        // The render order is not relevant for a heatmap representation.\n        _this.setRenderOrder(null);\n        return _this;\n    }\n    /**\n     * Return the blur size in pixels.\n     * @return {number} Blur size in pixels.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.getBlur = function () {\n        return /** @type {number} */ (this.get(Property.BLUR));\n    };\n    /**\n     * Return the gradient colors as array of strings.\n     * @return {Array<string>} Colors.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.getGradient = function () {\n        return /** @type {Array<string>} */ (this.get(Property.GRADIENT));\n    };\n    /**\n     * Return the size of the radius in pixels.\n     * @return {number} Radius size in pixel.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.getRadius = function () {\n        return /** @type {number} */ (this.get(Property.RADIUS));\n    };\n    /**\n     * @private\n     */\n    Heatmap.prototype.handleGradientChanged_ = function () {\n        this.gradient_ = createGradient(this.getGradient());\n    };\n    /**\n     * Set the blur size in pixels.\n     * @param {number} blur Blur size in pixels.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.setBlur = function (blur) {\n        this.set(Property.BLUR, blur);\n    };\n    /**\n     * Set the gradient colors as array of strings.\n     * @param {Array<string>} colors Gradient.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.setGradient = function (colors) {\n        this.set(Property.GRADIENT, colors);\n    };\n    /**\n     * Set the size of the radius in pixels.\n     * @param {number} radius Radius size in pixel.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.setRadius = function (radius) {\n        this.set(Property.RADIUS, radius);\n    };\n    Heatmap.prototype.createRenderer = function () {\n        return new WebGLPointsLayerRenderer(this, {\n            className: this.getClassName(),\n            attributes: [\n                {\n                    name: 'weight',\n                    callback: function (feature) {\n                        var weight = this.weightFunction_(feature);\n                        return weight !== undefined ? clamp(weight, 0, 1) : 1;\n                    }.bind(this),\n                },\n            ],\n            vertexShader: \"\\n        precision mediump float;\\n        uniform mat4 u_projectionMatrix;\\n        uniform mat4 u_offsetScaleMatrix;\\n        uniform float u_size;\\n        attribute vec2 a_position;\\n        attribute float a_index;\\n        attribute float a_weight;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n\\n        void main(void) {\\n          mat4 offsetMatrix = u_offsetScaleMatrix;\\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\\n          v_texCoord = vec2(u, v);\\n          v_weight = a_weight;\\n        }\",\n            fragmentShader: \"\\n        precision mediump float;\\n        uniform float u_blurSlope;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n\\n        void main(void) {\\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\\n        }\",\n            hitVertexShader: \"\\n        precision mediump float;\\n        uniform mat4 u_projectionMatrix;\\n        uniform mat4 u_offsetScaleMatrix;\\n        uniform float u_size;\\n        attribute vec2 a_position;\\n        attribute float a_index;\\n        attribute float a_weight;\\n        attribute vec4 a_hitColor;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n        varying vec4 v_hitColor;\\n\\n        void main(void) {\\n          mat4 offsetMatrix = u_offsetScaleMatrix;\\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\\n          v_texCoord = vec2(u, v);\\n          v_hitColor = a_hitColor;\\n          v_weight = a_weight;\\n        }\",\n            hitFragmentShader: \"\\n        precision mediump float;\\n        uniform float u_blurSlope;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n        varying vec4 v_hitColor;\\n\\n        void main(void) {\\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\\n          if (alpha < 0.05) {\\n            discard;\\n          }\\n\\n          gl_FragColor = v_hitColor;\\n        }\",\n            uniforms: {\n                u_size: function () {\n                    return (this.get(Property.RADIUS) + this.get(Property.BLUR)) * 2;\n                }.bind(this),\n                u_blurSlope: function () {\n                    return (this.get(Property.RADIUS) / Math.max(1, this.get(Property.BLUR)));\n                }.bind(this),\n            },\n            postProcesses: [\n                {\n                    fragmentShader: \"\\n            precision mediump float;\\n\\n            uniform sampler2D u_image;\\n            uniform sampler2D u_gradientTexture;\\n            uniform float u_opacity;\\n\\n            varying vec2 v_texCoord;\\n\\n            void main() {\\n              vec4 color = texture2D(u_image, v_texCoord);\\n              gl_FragColor.a = color.a * u_opacity;\\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\\n              gl_FragColor.rgb *= gl_FragColor.a;\\n            }\",\n                    uniforms: {\n                        u_gradientTexture: function () {\n                            return this.gradient_;\n                        }.bind(this),\n                        u_opacity: function () {\n                            return this.getOpacity();\n                        }.bind(this),\n                    },\n                },\n            ],\n        });\n    };\n    Heatmap.prototype.renderDeclutter = function () { };\n    return Heatmap;\n}(BaseVector));\n/**\n * @param {Array<string>} colors A list of colored.\n * @return {HTMLCanvasElement} canvas with gradient texture.\n */\nfunction createGradient(colors) {\n    var width = 1;\n    var height = 256;\n    var context = createCanvasContext2D(width, height);\n    var gradient = context.createLinearGradient(0, 0, width, height);\n    var step = 1 / (colors.length - 1);\n    for (var i = 0, ii = colors.length; i < ii; ++i) {\n        gradient.addColorStop(i * step, colors[i]);\n    }\n    context.fillStyle = gradient;\n    context.fillRect(0, 0, width, height);\n    return context.canvas;\n}\nexport default Heatmap;\n//# sourceMappingURL=Heatmap.js.map","import './style.css';\nimport {\n    Feature,\n    Map,\n    View,\n} from 'ol';\nimport OSM from 'ol/source/OSM';\nimport VectorSource from 'ol/source/Vector';\nimport Point from 'ol/geom/Point';\nimport {\n    fromLonLat,\n    useGeographic\n} from 'ol/proj';\nimport {\n    Heatmap as HeatmapLayer,\n    Tile as TileLayer,\n} from 'ol/layer';\n\nuseGeographic();\n\n\n// Loading the data\nconst parkingData = await fetch(\"data.json\")\n    .then(response => response.json())\n    .then(json => {\n        return json\n    });\nconsole.log(parkingData);\n\nlet startIndex = 0;\nlet endIndex = parkingData[\"Bezigrad\"].percent_occupied.length;\nlet i = startIndex;\n\n// Datepicker setup\n$('input[name=\"daterange\"]').daterangepicker({\n    locale: {\n        format: 'DD/MM/YYYY'\n    },\n    minDate: new Date(Math.min(...parkingData[\"Bezigrad\"].timestamps) * 1000),\n    maxDate: new Date(Math.max(...parkingData[\"Bezigrad\"].timestamps) * 1000),\n});\n\n$('input[name=\"daterange\"]').on('apply.daterangepicker', (ev, picker) => {\n    let startTime = Math.floor(picker.startDate._d.getTime() / 1000);\n    let endTime = Math.floor(picker.endDate._d.getTime() / 1000);\n\n    startIndex = -1;\n    endIndex = -1;\n    for (let idx = 0; idx < parkingData[\"Bezigrad\"].timestamps.length; idx++) {\n        console.log(idx);\n        if (startIndex == -1 && startTime <= parkingData[\"Bezigrad\"].timestamps[idx]) {\n            startIndex = idx;\n        }\n        if (endIndex == -1 && parkingData[\"Bezigrad\"].timestamps[idx] >= endTime) {\n            endIndex = idx;\n            break;\n        }\n    }\n    i = startIndex;\n    // console.log(startIndex, endIndex);\n});\n\nconst aSpeed = document.getElementById('speed');\nlet animationSpeed = 50;\nlet animationPlaying = false;\n$(\"#stop\").addClass(\"activeButton\");\n\n\n// Adding initial parking data\nlet data = new VectorSource();\n\ndata.addFeature(new Feature({\n    name: \"MAX\",\n    geometry: new Point(fromLonLat([0, 0, 0])),\n    magnitude: 1,\n}));\n\nconst parkingCoords = [\n    [14.517521, 46.039284, \"Dolenjska cesta (Strelisce)\"],\n    [14.508285, 46.062497, \"Bezigrad\"],\n    [14.514254, 46.087035, \"BS4/ I\"],\n    [14.514251, 46.086728, \"BS4/ II\"],\n    [14.518000, 46.074537, \"Gosarjeva ulica\"],\n    [14.515989, 46.074583, \"Gosarjeva ulica II.\"],\n    [14.510116, 46.061856, \"Gospodarsko razstavisce\"],\n    // [14.513173, 46.088353, \"Komanova ulica\"],\n    [14.503415, 46.050617, \"PH Kongresni trg\"],\n    [14.504961, 46.056943, \"Kozolec\"],\n    [14.522073, 46.070205, \"Kranjceva ulica\"],\n    [14.509180, 46.063127, \"Linhartova\"],\n    [14.516126, 46.056973, \"Metelkova ulica\"],\n    [14.494343, 46.046584, \"Mirje\"],\n    [14.501974, 46.046687, \"NUK II.\"],\n    //[14.499581, 46.026924, \"P+R Barje\"],\n    //[14.463085, 46.036492, \"P+R Dolgi most\"],\n    //[14.568027, 46.054279, \"P+R Studenec\"],\n    [14.493818, 46.042360, \"PH Kolezija\"],\n    [14.511568, 46.052130, \"Petkovskovo nabrezje II.\"],\n    [14.582565, 46.054942, \"Pokopalisce Polje\"],\n    [14.529375, 46.051250, \"Povsetova ulica\"],\n    [14.508596, 46.053622, \"Senatorij Emona\"],\n    [14.507321, 46.088504, \"Slovenceva ulica\"],\n    [14.500366, 46.056411, \"Tivoli I.\"],\n    [14.497231, 46.059912, \"Tivoli II.\"],\n    [14.495670, 46.046982, \"Trg mladinskih delovnih brigad\"],\n    [14.488943, 46.068388, \"Trg prekomorskih brigad\"],\n    // [14.515946, 46.078370, \"Stembalova ulica\"],\n    [14.528873, 46.068968, \"Zale I.\"],\n    [14.528680, 46.067131, \"Zale II.\"],\n    [14.526062, 46.067969, \"Zale III.\"],\n    [14.526815, 46.069497, \"Zale IV.\"],\n    [14.531361, 46.074782, \"Zale V.\"],\n]\nparkingCoords.forEach(parking => {\n    data.addFeature(new Feature({\n        name: parking[2],\n        geometry: new Point(fromLonLat([parking[0], parking[1], 0])),\n        magnitude: 0.0,\n    }));\n});\n\nconst vector = new HeatmapLayer({\n    source: data,\n    blur: 18,\n    radius: 20,\n    weight: (feature) => {\n        const name = feature.get('name');\n        const magnitude = feature.get('magnitude');\n        return magnitude;\n    },\n});\n\nconst raster = new TileLayer({\n    source: new OSM(),\n});\n\nconst map = new Map({\n    layers: [raster, vector],\n    target: 'map',\n    view: new View({\n        center: [14.505751, 46.056946],\n        zoom: 13,\n    }),\n});\n\n\n// Animation logic\nlet renderParkings = () => {\n    if (animationPlaying) {\n        data.forEachFeature(feat => {\n            let name = feat.getProperties().name;\n            if (name !== \"MAX\") {\n                let percent = parkingData[name].percent_occupied[i];\n                if (!(i < endIndex)) {\n                    animationPlaying = false;\n                    $(\"#play\").removeClass(\"activeButton\");\n                    $(\"#stop\").addClass(\"activeButton\");\n                }\n                feat.setProperties({\n                    magnitude: percent\n                });\n            }\n        });\n        map.render();\n        let time = new Date(parkingData[\"Bezigrad\"].timestamps[i] * 1000);\n\n        $(\"#currentTime\").html(`\n            <p>${time.toLocaleDateString()}</p>\n            <p>${time.toLocaleTimeString()}</p>\n        `);\n        // <p>${time.toLocaleDateString(\"sl-SL\", { weekday: 'long' })}</p>\n        i++;\n        // console.log(animationSpeed);\n        setTimeout(renderParkings, animationSpeed);\n    }\n}\n\n\n// UI handling\n$(\"#play\").click(() => {\n    if (!animationPlaying) {\n        animationPlaying = true;\n        setTimeout(renderParkings, animationSpeed);\n        $(\"#play\").addClass(\"activeButton\");\n        $(\"#stop\").removeClass(\"activeButton\");\n    }\n});\n$(\"#stop\").click(() => {\n    if (animationPlaying) {\n        animationPlaying = false;\n        $(\"#play\").removeClass(\"activeButton\");\n        $(\"#stop\").addClass(\"activeButton\");\n    }\n});\n\n\nconst animationSpeedHandler = () => {\n    animationSpeed = 500 - parseInt(aSpeed.value);\n};\naSpeed.addEventListener('input', animationSpeedHandler);\naSpeed.addEventListener('speed', animationSpeedHandler);"],"names":["__extends","this","createTransform","create","WebGLPostProcessingPass","resetTransform","scaleTransform","rotateTransform","composeTransform","applyTransform","WebGLArrayBuffer","createWebGLWorker","makeInverseTransform","WebGLRenderTarget","equals","BaseVector","multiplyTransform","WebGLLayerRenderer","WebGLPointsLayerRenderer"],"mappings":"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"}